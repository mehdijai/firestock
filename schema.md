# Product Stock Manager NoSQL Schema

## Collections

In the case of simplified Multi-Store Product Stock Management Data Model, We would have `Store`, `Product`, `Stock`, `Orders` and `Reservations`.

Following the convenience of Firestore and NoSQL principles. We would set these base models as Collections. And each model collection will have documents for its entries.

For the reservation, we will simplify the process and just add the amount reserved `reservedQuantity`. This value will tell us the reserved quantity from `quantity`. And `quantity` is the physical amount in the store.

> In more detailed architecture. Reservation would be its own document, and would have more details, with client ID linking the id of the client i question. This would provide more clarity and tracing.

## Product vs Stock

In the context of Stock management. We isolate the products catalog from the stock and inventory.

Product model is a document holding all the available products, their details and base price.

Stock, is a model that links a product to a store. In the domain aspect, It's the physical representation of product in the store's shelf or inventory.

The stock `key` is the barcode or the referenced product. This will make searching easier. Because the index of this stock item is the barcode of the product and can be scanned directly and looked up easily.

## Expirations

The expirations concept is linked to the physical representation of the products in the store. Thus, it will be an attribute in the stock rather than in Product.

In the model I've provided, expirations are a list (Array) of expiration date timestamp, and the quantity of products in the store with that date of expiration.

```json
"expirations": [
    {
        "date": "timestamp",
        "quantity": "number"
    }
],
"soonestExpirationDate": "timestamp"
```

`soonestExpirationDate` is a computed field, that takes the minimum date and stores it on creation or/and updates. The goal of this attribute, is to better filter soon expired products.

In the API, we would have an endpoint of expiration checks, This endpoint will check `soonestExpirationDate`, and fetch the quantity of products with the nearest expiration date + a tolerance value in days to alert the store to handle them.

In case of refilling the store, the products already existing would be just updated, and if the entered products with different expiration date, the `expirations` array attribute will be updated as well. and `soonestExpirationDate` will be recalculated.

## Orders

Orders in this Data model is simplified. I've worked on a full project for Stock Management, The Data Structure I provided is a very simplistic. In a real world stock manager app, there would be more details and more relations and tracking.

Order Model holds the store id to link to the store of purchase, `purchaseDate` as date of purchase, total price as the Total Taxed Price, status of the order that can be `PROCESSING | CANCELED | CONFIRMED | REFUNDED`.

Order items are reference of stock products with quantity selected, and the price of purchase of that product.
The price here is the price of the time of purchase. If the product's price changed, the prices in the orders will not be affected, thus the reports will be realistic.

We have `expirationDate` field as well. This field will help us in the refund process, where we can know which expiration date to increment. If that doesn't exist, we create a new item in `expirations` array.

## Identifiers

We have only two models that requires custom ID, `product` and `stock`. These two's ID is the barcode of the referenced physical product. And the remaining models can have the autogenerated ids.
